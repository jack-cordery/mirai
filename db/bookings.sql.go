// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bookings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAvailabilitySlot = `-- name: CreateAvailabilitySlot :one
INSERT INTO
  availability (employee_id, datetime, type_id)
VALUES
  ($1, $2, $3)
RETURNING
  id
`

type CreateAvailabilitySlotParams struct {
	EmployeeID int32            `json:"employee_id"`
	Datetime   pgtype.Timestamp `json:"datetime"`
	TypeID     int32            `json:"type_id"`
}

func (q *Queries) CreateAvailabilitySlot(ctx context.Context, arg CreateAvailabilitySlotParams) (int32, error) {
	row := q.db.QueryRow(ctx, createAvailabilitySlot, arg.EmployeeID, arg.Datetime, arg.TypeID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createBooking = `-- name: CreateBooking :one
WITH
  unit AS (
    SELECT
      $7::integer AS minutes
  ),
  new_booking as (
    INSERT INTO
      bookings (
        user_id,
        type_id,
        paid,
        cost,
        notes,
        status_updated_by
      )
    VALUES
      (
        $1,
        $2,
        $3,
        $4,
        $5,
        (
          SELECT
            email
          FROM
            users
          WHERE
            users.id = $1
        )
      )
    RETURNING
      id
  ),
  slot_insert AS (
    INSERT INTO
      booking_slots (booking_id, availability_slot_id)
    SELECT
      id,
      unnest($6::int[])
    FROM
      new_booking
    RETURNING
      booking_id,
      availability_slot_id
  ),
  slot_times AS (
    SELECT
      s.booking_id,
      MIN(a.datetime)::timestamp AS start_time,
      (
        MAX(a.datetime) + (
          (
            SELECT
              minutes
            from
              unit
          ) * INTERVAL '1 minute'
        )
      )::timestamp AS end_time
    FROM
      slot_insert s
      JOIN availability a ON s.availability_slot_id = a.id
    GROUP BY
      s.booking_id
  )
SELECT
  nb.id AS booking_id,
  st.start_time,
  st.end_time
FROM
  new_booking nb
  JOIN slot_times st ON nb.id = st.booking_id
`

type CreateBookingParams struct {
	UserID  int32       `json:"user_id"`
	TypeID  int32       `json:"type_id"`
	Paid    bool        `json:"paid"`
	Cost    int32       `json:"cost"`
	Notes   pgtype.Text `json:"notes"`
	Column6 []int32     `json:"column_6"`
	Column7 int32       `json:"column_7"`
}

type CreateBookingRow struct {
	BookingID int32            `json:"booking_id"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (CreateBookingRow, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.UserID,
		arg.TypeID,
		arg.Paid,
		arg.Cost,
		arg.Notes,
		arg.Column6,
		arg.Column7,
	)
	var i CreateBookingRow
	err := row.Scan(&i.BookingID, &i.StartTime, &i.EndTime)
	return i, err
}

const createBookingHistory = `-- name: CreateBookingHistory :exec
INSERT INTO
  booking_history (
    booking_id,
    start_time,
    end_time,
    status,
    changed_by_email
  )
VALUES
  ($1, $2, $3, $4, $5)
`

type CreateBookingHistoryParams struct {
	BookingID      int32            `json:"booking_id"`
	StartTime      pgtype.Timestamp `json:"start_time"`
	EndTime        pgtype.Timestamp `json:"end_time"`
	Status         BookingStatus    `json:"status"`
	ChangedByEmail string           `json:"changed_by_email"`
}

func (q *Queries) CreateBookingHistory(ctx context.Context, arg CreateBookingHistoryParams) error {
	_, err := q.db.Exec(ctx, createBookingHistory,
		arg.BookingID,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.ChangedByEmail,
	)
	return err
}

const createBookingSlot = `-- name: CreateBookingSlot :exec
INSERT INTO
  booking_slots (booking_id, availability_slot_id)
VALUES
  ($1, $2)
`

type CreateBookingSlotParams struct {
	BookingID          int32 `json:"booking_id"`
	AvailabilitySlotID int32 `json:"availability_slot_id"`
}

func (q *Queries) CreateBookingSlot(ctx context.Context, arg CreateBookingSlotParams) error {
	_, err := q.db.Exec(ctx, createBookingSlot, arg.BookingID, arg.AvailabilitySlotID)
	return err
}

const createBookingType = `-- name: CreateBookingType :one
INSERT INTO
  booking_types (title, description, fixed, cost)
VALUES
  ($1, $2, $3, $4)
RETURNING
  id
`

type CreateBookingTypeParams struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Fixed       bool   `json:"fixed"`
	Cost        int32  `json:"cost"`
}

func (q *Queries) CreateBookingType(ctx context.Context, arg CreateBookingTypeParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBookingType,
		arg.Title,
		arg.Description,
		arg.Fixed,
		arg.Cost,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO
  employees (name, surname, email, title, description)
VALUES
  ($1, $2, $3, $4, $5)
RETURNING
  id
`

type CreateEmployeeParams struct {
	Name        string `json:"name"`
	Surname     string `json:"surname"`
	Email       string `json:"email"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (int32, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.Name,
		arg.Surname,
		arg.Email,
		arg.Title,
		arg.Description,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAvailabilitySlot = `-- name: DeleteAvailabilitySlot :one
DELETE FROM availability
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteAvailabilitySlot(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteAvailabilitySlot, id)
	err := row.Scan(&id)
	return id, err
}

const deleteBooking = `-- name: DeleteBooking :one
DELETE FROM bookings
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteBooking(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteBooking, id)
	err := row.Scan(&id)
	return id, err
}

const deleteBookingSlot = `-- name: DeleteBookingSlot :exec
DELETE FROM booking_slots
WHERE
  booking_id = $1
  AND availability_slot_id = $2
`

type DeleteBookingSlotParams struct {
	BookingID          int32 `json:"booking_id"`
	AvailabilitySlotID int32 `json:"availability_slot_id"`
}

func (q *Queries) DeleteBookingSlot(ctx context.Context, arg DeleteBookingSlotParams) error {
	_, err := q.db.Exec(ctx, deleteBookingSlot, arg.BookingID, arg.AvailabilitySlotID)
	return err
}

const deleteBookingType = `-- name: DeleteBookingType :one
DELETE FROM booking_types
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteBookingType(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteBookingType, id)
	err := row.Scan(&id)
	return id, err
}

const deleteEmployee = `-- name: DeleteEmployee :one
DELETE FROM employees
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteEmployee(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteEmployee, id)
	err := row.Scan(&id)
	return id, err
}

const freeAvailabilitySlot = `-- name: FreeAvailabilitySlot :exec
DELETE FROM booking_slots
WHERE
  booking_id = $1
`

func (q *Queries) FreeAvailabilitySlot(ctx context.Context, bookingID int32) error {
	_, err := q.db.Exec(ctx, freeAvailabilitySlot, bookingID)
	return err
}

const getAllAvailabilitySlots = `-- name: GetAllAvailabilitySlots :many
SELECT
  id, employee_id, datetime, type_id, created_at, last_edited
FROM
  availability
`

func (q *Queries) GetAllAvailabilitySlots(ctx context.Context) ([]Availability, error) {
	rows, err := q.db.Query(ctx, getAllAvailabilitySlots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Availability
	for rows.Next() {
		var i Availability
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.Datetime,
			&i.TypeID,
			&i.CreatedAt,
			&i.LastEdited,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBookingTypes = `-- name: GetAllBookingTypes :many
SELECT
  id, title, description, fixed, cost, created_at, last_edited
FROM
  booking_types
`

func (q *Queries) GetAllBookingTypes(ctx context.Context) ([]BookingType, error) {
	rows, err := q.db.Query(ctx, getAllBookingTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingType
	for rows.Next() {
		var i BookingType
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Fixed,
			&i.Cost,
			&i.CreatedAt,
			&i.LastEdited,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBookings = `-- name: GetAllBookings :many
SELECT
  id, user_id, type_id, paid, cost, status, status_updated_at, status_updated_by, notes, created_at, last_edited
FROM
  bookings
`

func (q *Queries) GetAllBookings(ctx context.Context) ([]Booking, error) {
	rows, err := q.db.Query(ctx, getAllBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TypeID,
			&i.Paid,
			&i.Cost,
			&i.Status,
			&i.StatusUpdatedAt,
			&i.StatusUpdatedBy,
			&i.Notes,
			&i.CreatedAt,
			&i.LastEdited,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBookingsWithJoin = `-- name: GetAllBookingsWithJoin :many
WITH
  unit AS (
    SELECT
      $1::integer AS minutes
  ),
  cancelled_history AS (
    SELECT
      h.booking_id,
      (
        ARRAY_AGG(
          h.start_time
          ORDER BY
            h.changed_at DESC
        )
      ) [1] AS cancelled_start_time,
      (
        ARRAY_AGG(
          h.end_time
          ORDER BY
            h.changed_at DESC
        )
      ) [1] AS cancelled_end_time
    FROM
      booking_history h
    GROUP BY
      h.booking_id
  )
SELECT
  b.id,
  b.user_id,
  u.name AS user_name,
  u.surname AS user_surname,
  u.email AS user_email,
  u.last_login AS user_last_login,
  b.type_id,
  bt.title AS type_title,
  b.paid,
  b.cost,
  b.status,
  b.status_updated_at,
  b.status_updated_by,
  b.notes,
  b.created_at,
  b.last_edited,
  CASE
    WHEN b.status = 'cancelled' THEN ch.cancelled_start_time
    ELSE MIN(a.datetime)::timestamp
  END AS start_time,
  CASE
    WHEN b.status = 'cancelled' THEN ch.cancelled_end_time
    ELSE (
      MAX(a.datetime) + (
        SELECT
          minutes
        FROM
          unit
      ) * INTERVAL '1 minute'
    )::timestamp
  END AS end_time
FROM
  bookings b
  JOIN users u ON b.user_id = u.id
  JOIN booking_types bt ON b.type_id = bt.id
  LEFT JOIN booking_slots bs ON b.id = bs.booking_id
  LEFT JOIN availability a ON bs.availability_slot_id = a.id
  LEFT JOIN cancelled_history ch ON b.id = ch.booking_id
GROUP BY
  b.id,
  b.user_id,
  u.name,
  u.surname,
  u.email,
  u.last_login,
  b.type_id,
  bt.title,
  b.paid,
  b.cost,
  b.status,
  b.status_updated_at,
  b.status_updated_by,
  b.notes,
  b.created_at,
  b.last_edited,
  ch.cancelled_start_time,
  ch.cancelled_end_time
ORDER BY
  b.created_at DESC
`

type GetAllBookingsWithJoinRow struct {
	ID              int32            `json:"id"`
	UserID          int32            `json:"user_id"`
	UserName        string           `json:"user_name"`
	UserSurname     string           `json:"user_surname"`
	UserEmail       string           `json:"user_email"`
	UserLastLogin   pgtype.Timestamp `json:"user_last_login"`
	TypeID          int32            `json:"type_id"`
	TypeTitle       string           `json:"type_title"`
	Paid            bool             `json:"paid"`
	Cost            int32            `json:"cost"`
	Status          BookingStatus    `json:"status"`
	StatusUpdatedAt pgtype.Timestamp `json:"status_updated_at"`
	StatusUpdatedBy string           `json:"status_updated_by"`
	Notes           pgtype.Text      `json:"notes"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	LastEdited      pgtype.Timestamp `json:"last_edited"`
	StartTime       pgtype.Timestamp `json:"start_time"`
	EndTime         pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) GetAllBookingsWithJoin(ctx context.Context, dollar_1 int32) ([]GetAllBookingsWithJoinRow, error) {
	rows, err := q.db.Query(ctx, getAllBookingsWithJoin, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBookingsWithJoinRow
	for rows.Next() {
		var i GetAllBookingsWithJoinRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserName,
			&i.UserSurname,
			&i.UserEmail,
			&i.UserLastLogin,
			&i.TypeID,
			&i.TypeTitle,
			&i.Paid,
			&i.Cost,
			&i.Status,
			&i.StatusUpdatedAt,
			&i.StatusUpdatedBy,
			&i.Notes,
			&i.CreatedAt,
			&i.LastEdited,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailabilitySlotById = `-- name: GetAvailabilitySlotById :one
SELECT
  id, employee_id, datetime, type_id, created_at, last_edited
FROM
  availability
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetAvailabilitySlotById(ctx context.Context, id int32) (Availability, error) {
	row := q.db.QueryRow(ctx, getAvailabilitySlotById, id)
	var i Availability
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.Datetime,
		&i.TypeID,
		&i.CreatedAt,
		&i.LastEdited,
	)
	return i, err
}

const getBookingById = `-- name: GetBookingById :one
SELECT
  b.id,
  b.user_id,
  b.type_id,
  b.paid,
  b.cost,
  b.status,
  b.status_updated_at,
  b.status_updated_by,
  b.notes,
  b.created_at,
  b.last_edited,
  array_agg(
    bs.availability_slot_id
    ORDER BY
      bs.availability_slot_id
  )::int[] AS slot_ids
FROM
  bookings b
  LEFT JOIN booking_slots bs ON b.id = bs.booking_id
WHERE
  b.id = $1
GROUP BY
  b.id
LIMIT
  1
`

type GetBookingByIdRow struct {
	ID              int32            `json:"id"`
	UserID          int32            `json:"user_id"`
	TypeID          int32            `json:"type_id"`
	Paid            bool             `json:"paid"`
	Cost            int32            `json:"cost"`
	Status          BookingStatus    `json:"status"`
	StatusUpdatedAt pgtype.Timestamp `json:"status_updated_at"`
	StatusUpdatedBy string           `json:"status_updated_by"`
	Notes           pgtype.Text      `json:"notes"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	LastEdited      pgtype.Timestamp `json:"last_edited"`
	SlotIds         []int32          `json:"slot_ids"`
}

func (q *Queries) GetBookingById(ctx context.Context, id int32) (GetBookingByIdRow, error) {
	row := q.db.QueryRow(ctx, getBookingById, id)
	var i GetBookingByIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TypeID,
		&i.Paid,
		&i.Cost,
		&i.Status,
		&i.StatusUpdatedAt,
		&i.StatusUpdatedBy,
		&i.Notes,
		&i.CreatedAt,
		&i.LastEdited,
		&i.SlotIds,
	)
	return i, err
}

const getBookingTypeById = `-- name: GetBookingTypeById :one
SELECT
  id, title, description, fixed, cost, created_at, last_edited
FROM
  booking_types
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetBookingTypeById(ctx context.Context, id int32) (BookingType, error) {
	row := q.db.QueryRow(ctx, getBookingTypeById, id)
	var i BookingType
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Fixed,
		&i.Cost,
		&i.CreatedAt,
		&i.LastEdited,
	)
	return i, err
}

const getBookingWithJoin = `-- name: GetBookingWithJoin :one
WITH
  unit AS (
    SELECT
      $1::integer AS minutes
  ),
  cancelled_history AS (
    SELECT
      h.booking_id,
      (
        ARRAY_AGG(
          h.start_time
          ORDER BY
            h.changed_at DESC
        )
      ) [1] AS cancelled_start_time,
      (
        ARRAY_AGG(
          h.end_time
          ORDER BY
            h.changed_at DESC
        )
      ) [1] AS cancelled_end_time
    FROM
      booking_history h
    GROUP BY
      h.booking_id
  )
SELECT
  b.id,
  b.user_id,
  u.name AS user_name,
  u.surname AS user_surname,
  u.email AS user_email,
  u.last_login AS user_last_login,
  b.type_id,
  bt.title AS type_title,
  b.paid,
  b.cost,
  b.status,
  b.status_updated_at,
  b.status_updated_by,
  b.notes,
  b.created_at,
  b.last_edited,
  CASE
    WHEN b.status = 'cancelled' THEN ch.cancelled_start_time
    ELSE MIN(a.datetime)::timestamp
  END AS start_time,
  CASE
    WHEN b.status = 'cancelled' THEN ch.cancelled_end_time
    ELSE (
      MAX(a.datetime) + (
        SELECT
          minutes
        FROM
          unit
      ) * INTERVAL '1 minute'
    )::timestamp
  END AS end_time
FROM
  bookings b
  JOIN users u ON b.user_id = u.id
  JOIN booking_types bt ON b.type_id = bt.id
  LEFT JOIN booking_slots bs ON b.id = bs.booking_id
  LEFT JOIN availability a ON bs.availability_slot_id = a.id
  LEFT JOIN cancelled_history ch ON b.id = ch.booking_id
WHERE
  b.id = $2
GROUP BY
  b.id,
  b.user_id,
  u.name,
  u.surname,
  u.email,
  u.last_login,
  b.type_id,
  bt.title,
  b.paid,
  b.cost,
  b.status,
  b.status_updated_at,
  b.status_updated_by,
  b.notes,
  b.created_at,
  b.last_edited,
  ch.cancelled_start_time,
  ch.cancelled_end_time
ORDER BY
  b.created_at DESC
`

type GetBookingWithJoinParams struct {
	Column1 int32 `json:"column_1"`
	ID      int32 `json:"id"`
}

type GetBookingWithJoinRow struct {
	ID              int32            `json:"id"`
	UserID          int32            `json:"user_id"`
	UserName        string           `json:"user_name"`
	UserSurname     string           `json:"user_surname"`
	UserEmail       string           `json:"user_email"`
	UserLastLogin   pgtype.Timestamp `json:"user_last_login"`
	TypeID          int32            `json:"type_id"`
	TypeTitle       string           `json:"type_title"`
	Paid            bool             `json:"paid"`
	Cost            int32            `json:"cost"`
	Status          BookingStatus    `json:"status"`
	StatusUpdatedAt pgtype.Timestamp `json:"status_updated_at"`
	StatusUpdatedBy string           `json:"status_updated_by"`
	Notes           pgtype.Text      `json:"notes"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	LastEdited      pgtype.Timestamp `json:"last_edited"`
	StartTime       pgtype.Timestamp `json:"start_time"`
	EndTime         pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) GetBookingWithJoin(ctx context.Context, arg GetBookingWithJoinParams) (GetBookingWithJoinRow, error) {
	row := q.db.QueryRow(ctx, getBookingWithJoin, arg.Column1, arg.ID)
	var i GetBookingWithJoinRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserName,
		&i.UserSurname,
		&i.UserEmail,
		&i.UserLastLogin,
		&i.TypeID,
		&i.TypeTitle,
		&i.Paid,
		&i.Cost,
		&i.Status,
		&i.StatusUpdatedAt,
		&i.StatusUpdatedBy,
		&i.Notes,
		&i.CreatedAt,
		&i.LastEdited,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const postManualPayment = `-- name: PostManualPayment :exec
UPDATE bookings
SET
  paid = true
WHERE
  id = $1
`

func (q *Queries) PostManualPayment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, postManualPayment, id)
	return err
}

const updateAvailabilitySlot = `-- name: UpdateAvailabilitySlot :one
UPDATE availability
SET
  id = $1,
  employee_id = $2,
  datetime = $3,
  type_id = $4,
  created_at = DEFAULT,
  last_edited = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateAvailabilitySlotParams struct {
	ID         int32            `json:"id"`
	EmployeeID int32            `json:"employee_id"`
	Datetime   pgtype.Timestamp `json:"datetime"`
	TypeID     int32            `json:"type_id"`
}

func (q *Queries) UpdateAvailabilitySlot(ctx context.Context, arg UpdateAvailabilitySlotParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateAvailabilitySlot,
		arg.ID,
		arg.EmployeeID,
		arg.Datetime,
		arg.TypeID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateBooking = `-- name: UpdateBooking :one
UPDATE bookings
SET
  user_id = $2,
  type_id = $3,
  paid = $4,
  cost = $5,
  notes = $6,
  status_updated_by = $7,
  last_edited = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateBookingParams struct {
	ID              int32       `json:"id"`
	UserID          int32       `json:"user_id"`
	TypeID          int32       `json:"type_id"`
	Paid            bool        `json:"paid"`
	Cost            int32       `json:"cost"`
	Notes           pgtype.Text `json:"notes"`
	StatusUpdatedBy string      `json:"status_updated_by"`
}

func (q *Queries) UpdateBooking(ctx context.Context, arg UpdateBookingParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateBooking,
		arg.ID,
		arg.UserID,
		arg.TypeID,
		arg.Paid,
		arg.Cost,
		arg.Notes,
		arg.StatusUpdatedBy,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateBookingSlot = `-- name: UpdateBookingSlot :exec
UPDATE booking_slots
SET
  booking_id = $3,
  availability_slot_id = $4
WHERE
  booking_id = $1
  AND availability_slot_id = $2
`

type UpdateBookingSlotParams struct {
	BookingID            int32 `json:"booking_id"`
	AvailabilitySlotID   int32 `json:"availability_slot_id"`
	BookingID_2          int32 `json:"booking_id_2"`
	AvailabilitySlotID_2 int32 `json:"availability_slot_id_2"`
}

func (q *Queries) UpdateBookingSlot(ctx context.Context, arg UpdateBookingSlotParams) error {
	_, err := q.db.Exec(ctx, updateBookingSlot,
		arg.BookingID,
		arg.AvailabilitySlotID,
		arg.BookingID_2,
		arg.AvailabilitySlotID_2,
	)
	return err
}

const updateBookingStatus = `-- name: UpdateBookingStatus :exec
UPDATE bookings
SET
  status = $2,
  status_updated_by = $3,
  status_updated_at = DEFAULT
WHERE
  id = $1
`

type UpdateBookingStatusParams struct {
	ID              int32         `json:"id"`
	Status          BookingStatus `json:"status"`
	StatusUpdatedBy string        `json:"status_updated_by"`
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) error {
	_, err := q.db.Exec(ctx, updateBookingStatus, arg.ID, arg.Status, arg.StatusUpdatedBy)
	return err
}

const updateBookingType = `-- name: UpdateBookingType :one
UPDATE booking_types
SET
  id = $1,
  title = $2,
  description = $3,
  fixed = $4,
  cost = $5,
  created_at = DEFAULT,
  last_edited = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateBookingTypeParams struct {
	ID          int32  `json:"id"`
	Title       string `json:"title"`
	Description string `json:"description"`
	Fixed       bool   `json:"fixed"`
	Cost        int32  `json:"cost"`
}

func (q *Queries) UpdateBookingType(ctx context.Context, arg UpdateBookingTypeParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateBookingType,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Fixed,
		arg.Cost,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE employees
SET
  id = $1,
  name = $2,
  surname = $3,
  email = $4,
  title = $5,
  description = $6,
  created_at = DEFAULT,
  last_login = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateEmployeeParams struct {
	ID          int32  `json:"id"`
	Name        string `json:"name"`
	Surname     string `json:"surname"`
	Email       string `json:"email"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateEmployee,
		arg.ID,
		arg.Name,
		arg.Surname,
		arg.Email,
		arg.Title,
		arg.Description,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
