// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bookings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAvailabilitySlot = `-- name: CreateAvailabilitySlot :one
INSERT INTO
  availability (employee_id, datetime, type_id)
VALUES
  ($1, $2, $3)
RETURNING
  id
`

type CreateAvailabilitySlotParams struct {
	EmployeeID int32            `json:"employee_id"`
	Datetime   pgtype.Timestamp `json:"datetime"`
	TypeID     int32            `json:"type_id"`
}

func (q *Queries) CreateAvailabilitySlot(ctx context.Context, arg CreateAvailabilitySlotParams) (int32, error) {
	row := q.db.QueryRow(ctx, createAvailabilitySlot, arg.EmployeeID, arg.Datetime, arg.TypeID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createBooking = `-- name: CreateBooking :one
WITH
  new_booking as (
    INSERT INTO
      bookings (user_id, type_id, paid, cost, notes)
    VALUES
      ($1, $2, $3, $4, $5)
    RETURNING
      id
  )
INSERT INTO
  booking_slots (booking_id, availability_slot_id)
SELECT
  id,
  unnest($6::int[])
FROM
  new_booking
RETURNING
  booking_id
`

type CreateBookingParams struct {
	UserID  int32       `json:"user_id"`
	TypeID  int32       `json:"type_id"`
	Paid    bool        `json:"paid"`
	Cost    int32       `json:"cost"`
	Notes   pgtype.Text `json:"notes"`
	Column6 []int32     `json:"column_6"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.UserID,
		arg.TypeID,
		arg.Paid,
		arg.Cost,
		arg.Notes,
		arg.Column6,
	)
	var booking_id int32
	err := row.Scan(&booking_id)
	return booking_id, err
}

const createBookingSlot = `-- name: CreateBookingSlot :exec
INSERT INTO
  booking_slots (booking_id, availability_slot_id)
VALUES
  ($1, $2)
`

type CreateBookingSlotParams struct {
	BookingID          int32 `json:"booking_id"`
	AvailabilitySlotID int32 `json:"availability_slot_id"`
}

func (q *Queries) CreateBookingSlot(ctx context.Context, arg CreateBookingSlotParams) error {
	_, err := q.db.Exec(ctx, createBookingSlot, arg.BookingID, arg.AvailabilitySlotID)
	return err
}

const createBookingType = `-- name: CreateBookingType :one
INSERT INTO
  booking_types (title, description, fixed, cost)
VALUES
  ($1, $2, $3, $4)
RETURNING
  id
`

type CreateBookingTypeParams struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Fixed       bool   `json:"fixed"`
	Cost        int32  `json:"cost"`
}

func (q *Queries) CreateBookingType(ctx context.Context, arg CreateBookingTypeParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBookingType,
		arg.Title,
		arg.Description,
		arg.Fixed,
		arg.Cost,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO
  employees (name, surname, email, title, description)
VALUES
  ($1, $2, $3, $4, $5)
RETURNING
  id
`

type CreateEmployeeParams struct {
	Name        string `json:"name"`
	Surname     string `json:"surname"`
	Email       string `json:"email"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (int32, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.Name,
		arg.Surname,
		arg.Email,
		arg.Title,
		arg.Description,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAvailabilitySlot = `-- name: DeleteAvailabilitySlot :one
DELETE FROM availability
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteAvailabilitySlot(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteAvailabilitySlot, id)
	err := row.Scan(&id)
	return id, err
}

const deleteBooking = `-- name: DeleteBooking :one
DELETE FROM bookings
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteBooking(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteBooking, id)
	err := row.Scan(&id)
	return id, err
}

const deleteBookingSlot = `-- name: DeleteBookingSlot :exec
DELETE FROM booking_slots
WHERE
  booking_id = $1
  AND availability_slot_id = $2
`

type DeleteBookingSlotParams struct {
	BookingID          int32 `json:"booking_id"`
	AvailabilitySlotID int32 `json:"availability_slot_id"`
}

func (q *Queries) DeleteBookingSlot(ctx context.Context, arg DeleteBookingSlotParams) error {
	_, err := q.db.Exec(ctx, deleteBookingSlot, arg.BookingID, arg.AvailabilitySlotID)
	return err
}

const deleteBookingType = `-- name: DeleteBookingType :one
DELETE FROM booking_types
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteBookingType(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteBookingType, id)
	err := row.Scan(&id)
	return id, err
}

const deleteEmployee = `-- name: DeleteEmployee :one
DELETE FROM employees
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteEmployee(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteEmployee, id)
	err := row.Scan(&id)
	return id, err
}

const getAllAvailabilitySlots = `-- name: GetAllAvailabilitySlots :many
SELECT
  id, employee_id, datetime, type_id, created_at, last_edited
FROM
  availability
`

func (q *Queries) GetAllAvailabilitySlots(ctx context.Context) ([]Availability, error) {
	rows, err := q.db.Query(ctx, getAllAvailabilitySlots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Availability
	for rows.Next() {
		var i Availability
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.Datetime,
			&i.TypeID,
			&i.CreatedAt,
			&i.LastEdited,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBookingTypes = `-- name: GetAllBookingTypes :many
SELECT
  id, title, description, fixed, cost, created_at, last_edited
FROM
  booking_types
`

func (q *Queries) GetAllBookingTypes(ctx context.Context) ([]BookingType, error) {
	rows, err := q.db.Query(ctx, getAllBookingTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingType
	for rows.Next() {
		var i BookingType
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Fixed,
			&i.Cost,
			&i.CreatedAt,
			&i.LastEdited,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBookings = `-- name: GetAllBookings :many
SELECT
  id, user_id, type_id, paid, cost, notes, created_at, last_edited
FROM
  bookings
`

func (q *Queries) GetAllBookings(ctx context.Context) ([]Booking, error) {
	rows, err := q.db.Query(ctx, getAllBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TypeID,
			&i.Paid,
			&i.Cost,
			&i.Notes,
			&i.CreatedAt,
			&i.LastEdited,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBookingsWithJoin = `-- name: GetAllBookingsWithJoin :many
WITH
  unit AS (
    SELECT
      $1::integer AS minutes
  )
SELECT
  b.id,
  b.user_id,
  u.name AS user_name,
  u.surname AS user_surname,
  u.email AS user_email,
  u.last_login AS user_last_login,
  b.type_id,
  bt.title AS type_title,
  b.paid,
  b.cost,
  b.notes,
  b.created_at,
  b.last_edited,
  MIN(a.datetime)::timestamp AS start_time,
  (MAX(a.datetime) + (
    SELECT
      minutes
    FROM
      unit
  ) * INTERVAL '1 minute')::timestamp AS end_time
FROM
  bookings b
  JOIN users u ON b.user_id = u.id
  JOIN booking_types bt ON b.type_id = bt.id
  LEFT JOIN booking_slots bs ON b.id = bs.booking_id
  LEFT JOIN availability a ON bs.availability_slot_id = a.id
GROUP BY
  b.id,
  b.user_id,
  u.name,
  u.surname,
  u.email,
  u.last_login,
  b.type_id,
  bt.title,
  b.paid,
  b.cost,
  b.notes,
  b.created_at,
  b.last_edited
ORDER BY
  b.created_at DESC
`

type GetAllBookingsWithJoinRow struct {
	ID            int32            `json:"id"`
	UserID        int32            `json:"user_id"`
	UserName      string           `json:"user_name"`
	UserSurname   string           `json:"user_surname"`
	UserEmail     string           `json:"user_email"`
	UserLastLogin pgtype.Timestamp `json:"user_last_login"`
	TypeID        int32            `json:"type_id"`
	TypeTitle     string           `json:"type_title"`
	Paid          bool             `json:"paid"`
	Cost          int32            `json:"cost"`
	Notes         pgtype.Text      `json:"notes"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	LastEdited    pgtype.Timestamp `json:"last_edited"`
	StartTime     pgtype.Timestamp `json:"start_time"`
	EndTime       pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) GetAllBookingsWithJoin(ctx context.Context, dollar_1 int32) ([]GetAllBookingsWithJoinRow, error) {
	rows, err := q.db.Query(ctx, getAllBookingsWithJoin, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBookingsWithJoinRow
	for rows.Next() {
		var i GetAllBookingsWithJoinRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserName,
			&i.UserSurname,
			&i.UserEmail,
			&i.UserLastLogin,
			&i.TypeID,
			&i.TypeTitle,
			&i.Paid,
			&i.Cost,
			&i.Notes,
			&i.CreatedAt,
			&i.LastEdited,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailabilitySlotById = `-- name: GetAvailabilitySlotById :one
SELECT
  id, employee_id, datetime, type_id, created_at, last_edited
FROM
  availability
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetAvailabilitySlotById(ctx context.Context, id int32) (Availability, error) {
	row := q.db.QueryRow(ctx, getAvailabilitySlotById, id)
	var i Availability
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.Datetime,
		&i.TypeID,
		&i.CreatedAt,
		&i.LastEdited,
	)
	return i, err
}

const getBookingById = `-- name: GetBookingById :one
SELECT
  b.id,
  b.user_id,
  b.type_id,
  b.paid,
  b.cost,
  b.notes,
  b.created_at,
  b.last_edited,
  array_agg(
    bs.availability_slot_id
    ORDER BY
      bs.availability_slot_id
  )::int[] AS slot_ids
FROM
  bookings b
  LEFT JOIN booking_slots bs ON b.id = bs.booking_id
WHERE
  b.id = $1
GROUP BY
  b.id
LIMIT
  1
`

type GetBookingByIdRow struct {
	ID         int32            `json:"id"`
	UserID     int32            `json:"user_id"`
	TypeID     int32            `json:"type_id"`
	Paid       bool             `json:"paid"`
	Cost       int32            `json:"cost"`
	Notes      pgtype.Text      `json:"notes"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	LastEdited pgtype.Timestamp `json:"last_edited"`
	SlotIds    []int32          `json:"slot_ids"`
}

func (q *Queries) GetBookingById(ctx context.Context, id int32) (GetBookingByIdRow, error) {
	row := q.db.QueryRow(ctx, getBookingById, id)
	var i GetBookingByIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TypeID,
		&i.Paid,
		&i.Cost,
		&i.Notes,
		&i.CreatedAt,
		&i.LastEdited,
		&i.SlotIds,
	)
	return i, err
}

const getBookingTypeById = `-- name: GetBookingTypeById :one
SELECT
  id, title, description, fixed, cost, created_at, last_edited
FROM
  booking_types
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetBookingTypeById(ctx context.Context, id int32) (BookingType, error) {
	row := q.db.QueryRow(ctx, getBookingTypeById, id)
	var i BookingType
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Fixed,
		&i.Cost,
		&i.CreatedAt,
		&i.LastEdited,
	)
	return i, err
}

const updateAvailabilitySlot = `-- name: UpdateAvailabilitySlot :one
UPDATE availability
SET
  id = $1,
  employee_id = $2,
  datetime = $3,
  type_id = $4,
  created_at = DEFAULT,
  last_edited = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateAvailabilitySlotParams struct {
	ID         int32            `json:"id"`
	EmployeeID int32            `json:"employee_id"`
	Datetime   pgtype.Timestamp `json:"datetime"`
	TypeID     int32            `json:"type_id"`
}

func (q *Queries) UpdateAvailabilitySlot(ctx context.Context, arg UpdateAvailabilitySlotParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateAvailabilitySlot,
		arg.ID,
		arg.EmployeeID,
		arg.Datetime,
		arg.TypeID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateBooking = `-- name: UpdateBooking :one
UPDATE bookings
SET
  user_id = $2,
  type_id = $3,
  paid = $4,
  cost = $5,
  notes = $6,
  last_edited = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateBookingParams struct {
	ID     int32       `json:"id"`
	UserID int32       `json:"user_id"`
	TypeID int32       `json:"type_id"`
	Paid   bool        `json:"paid"`
	Cost   int32       `json:"cost"`
	Notes  pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateBooking(ctx context.Context, arg UpdateBookingParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateBooking,
		arg.ID,
		arg.UserID,
		arg.TypeID,
		arg.Paid,
		arg.Cost,
		arg.Notes,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateBookingSlot = `-- name: UpdateBookingSlot :exec
UPDATE booking_slots
SET
  booking_id = $3,
  availability_slot_id = $4
WHERE
  booking_id = $1
  AND availability_slot_id = $2
`

type UpdateBookingSlotParams struct {
	BookingID            int32 `json:"booking_id"`
	AvailabilitySlotID   int32 `json:"availability_slot_id"`
	BookingID_2          int32 `json:"booking_id_2"`
	AvailabilitySlotID_2 int32 `json:"availability_slot_id_2"`
}

func (q *Queries) UpdateBookingSlot(ctx context.Context, arg UpdateBookingSlotParams) error {
	_, err := q.db.Exec(ctx, updateBookingSlot,
		arg.BookingID,
		arg.AvailabilitySlotID,
		arg.BookingID_2,
		arg.AvailabilitySlotID_2,
	)
	return err
}

const updateBookingType = `-- name: UpdateBookingType :one
UPDATE booking_types
SET
  id = $1,
  title = $2,
  description = $3,
  fixed = $4,
  cost = $5,
  created_at = DEFAULT,
  last_edited = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateBookingTypeParams struct {
	ID          int32  `json:"id"`
	Title       string `json:"title"`
	Description string `json:"description"`
	Fixed       bool   `json:"fixed"`
	Cost        int32  `json:"cost"`
}

func (q *Queries) UpdateBookingType(ctx context.Context, arg UpdateBookingTypeParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateBookingType,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Fixed,
		arg.Cost,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE employees
SET
  id = $1,
  name = $2,
  surname = $3,
  email = $4,
  title = $5,
  description = $6,
  created_at = DEFAULT,
  last_login = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateEmployeeParams struct {
	ID          int32  `json:"id"`
	Name        string `json:"name"`
	Surname     string `json:"surname"`
	Email       string `json:"email"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateEmployee,
		arg.ID,
		arg.Name,
		arg.Surname,
		arg.Email,
		arg.Title,
		arg.Description,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
