// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignRoleToUser = `-- name: AssignRoleToUser :exec
INSERT INTO
  user_roles (user_id, role_id)
VALUES
  ($1, $2)
`

type AssignRoleToUserParams struct {
	UserID int32 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignRoleToUser, arg.UserID, arg.RoleID)
	return err
}

const createNewRoleRequest = `-- name: CreateNewRoleRequest :one
INSERT INTO
  role_requests (user_id, requested_role_id, comment)
VALUES
  ($1, $2, $3)
RETURNING
  id
`

type CreateNewRoleRequestParams struct {
	UserID          int32       `json:"user_id"`
	RequestedRoleID int32       `json:"requested_role_id"`
	Comment         pgtype.Text `json:"comment"`
}

func (q *Queries) CreateNewRoleRequest(ctx context.Context, arg CreateNewRoleRequestParams) (int32, error) {
	row := q.db.QueryRow(ctx, createNewRoleRequest, arg.UserID, arg.RequestedRoleID, arg.Comment)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO
  sessions (user_id, session_token, expires_at)
VALUES
  ($1, $2, $3)
RETURNING
  id
`

type CreateSessionParams struct {
	UserID       int32            `json:"user_id"`
	SessionToken string           `json:"session_token"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (int32, error) {
	row := q.db.QueryRow(ctx, createSession, arg.UserID, arg.SessionToken, arg.ExpiresAt)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
  users (name, surname, email, hashed_password)
VALUES
  ($1, $2, $3, $4)
RETURNING
  id
`

type CreateUserParams struct {
	Name           string `json:"name"`
	Surname        string `json:"surname"`
	Email          string `json:"email"`
	HashedPassword string `json:"hashed_password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Surname,
		arg.Email,
		arg.HashedPassword,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions
WHERE
  expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteSessionByToken = `-- name: DeleteSessionByToken :exec
DELETE FROM sessions
WHERE
  session_token = $1
`

func (q *Queries) DeleteSessionByToken(ctx context.Context, sessionToken string) error {
	_, err := q.db.Exec(ctx, deleteSessionByToken, sessionToken)
	return err
}

const deleteSessionsByUserID = `-- name: DeleteSessionsByUserID :exec
DELETE FROM sessions
WHERE
  user_id = $1
`

func (q *Queries) DeleteSessionsByUserID(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteSessionsByUserID, userID)
	return err
}

const deleteUser = `-- name: DeleteUser :one
DELETE FROM users
WHERE
  id = $1
RETURNING
  id
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteUser, id)
	err := row.Scan(&id)
	return id, err
}

const getAllEmployees = `-- name: GetAllEmployees :many
SELECT
  id, name, surname, email, title, description, active, created_at, last_login
FROM
  employees
WHERE
  active = true
`

func (q *Queries) GetAllEmployees(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.Query(ctx, getAllEmployees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Surname,
			&i.Email,
			&i.Title,
			&i.Description,
			&i.Active,
			&i.CreatedAt,
			&i.LastLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRoleRequests = `-- name: GetAllRoleRequests :many
SELECT
  id, user_id, requested_role_id, status, comment, approved_by, created_at, approved_at
FROM
  role_requests
`

func (q *Queries) GetAllRoleRequests(ctx context.Context) ([]RoleRequest, error) {
	rows, err := q.db.Query(ctx, getAllRoleRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoleRequest
	for rows.Next() {
		var i RoleRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RequestedRoleID,
			&i.Status,
			&i.Comment,
			&i.ApprovedBy,
			&i.CreatedAt,
			&i.ApprovedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRoleRequestsWithJoin = `-- name: GetAllRoleRequestsWithJoin :many
SELECT
  rr.id AS id,
  rr.user_id AS requesting_user_id,
  rr.requested_role_id AS requested_role_id,
  rr.status AS status,
  rr.comment AS comment,
  rr.approved_by AS approving_user_id,
  rr.created_at AS created_at,
  rr.approved_at AS approved_at,
  -- Requesting user info
  ru.name AS requesting_user_name,
  ru.surname AS requesting_user_surname,
  ru.email AS requesting_user_email,
  ru.created_at AS requesting_user_created_at,
  ru.last_login AS requesting_user_last_login,
  -- Requested role info
  r.name AS requested_role_name,
  r.description AS requested_role_description,
  -- Approving user info
  au.name AS approving_user_name,
  au.surname AS approving_user_surname,
  au.email AS approving_user_email,
  au.created_at AS approving_user_created_at,
  au.last_login AS approving_user_last_login
FROM
  role_requests rr
  LEFT JOIN users ru ON rr.user_id = ru.id
  LEFT JOIN roles r ON rr.requested_role_id = r.id
  LEFT JOIN users au ON rr.approved_by = au.id
`

type GetAllRoleRequestsWithJoinRow struct {
	ID                       int32             `json:"id"`
	RequestingUserID         int32             `json:"requesting_user_id"`
	RequestedRoleID          int32             `json:"requested_role_id"`
	Status                   RoleRequestStatus `json:"status"`
	Comment                  pgtype.Text       `json:"comment"`
	ApprovingUserID          pgtype.Int4       `json:"approving_user_id"`
	CreatedAt                pgtype.Timestamp  `json:"created_at"`
	ApprovedAt               pgtype.Timestamp  `json:"approved_at"`
	RequestingUserName       pgtype.Text       `json:"requesting_user_name"`
	RequestingUserSurname    pgtype.Text       `json:"requesting_user_surname"`
	RequestingUserEmail      pgtype.Text       `json:"requesting_user_email"`
	RequestingUserCreatedAt  pgtype.Timestamp  `json:"requesting_user_created_at"`
	RequestingUserLastLogin  pgtype.Timestamp  `json:"requesting_user_last_login"`
	RequestedRoleName        pgtype.Text       `json:"requested_role_name"`
	RequestedRoleDescription pgtype.Text       `json:"requested_role_description"`
	ApprovingUserName        pgtype.Text       `json:"approving_user_name"`
	ApprovingUserSurname     pgtype.Text       `json:"approving_user_surname"`
	ApprovingUserEmail       pgtype.Text       `json:"approving_user_email"`
	ApprovingUserCreatedAt   pgtype.Timestamp  `json:"approving_user_created_at"`
	ApprovingUserLastLogin   pgtype.Timestamp  `json:"approving_user_last_login"`
}

func (q *Queries) GetAllRoleRequestsWithJoin(ctx context.Context) ([]GetAllRoleRequestsWithJoinRow, error) {
	rows, err := q.db.Query(ctx, getAllRoleRequestsWithJoin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRoleRequestsWithJoinRow
	for rows.Next() {
		var i GetAllRoleRequestsWithJoinRow
		if err := rows.Scan(
			&i.ID,
			&i.RequestingUserID,
			&i.RequestedRoleID,
			&i.Status,
			&i.Comment,
			&i.ApprovingUserID,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.RequestingUserName,
			&i.RequestingUserSurname,
			&i.RequestingUserEmail,
			&i.RequestingUserCreatedAt,
			&i.RequestingUserLastLogin,
			&i.RequestedRoleName,
			&i.RequestedRoleDescription,
			&i.ApprovingUserName,
			&i.ApprovingUserSurname,
			&i.ApprovingUserEmail,
			&i.ApprovingUserCreatedAt,
			&i.ApprovingUserLastLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeById = `-- name: GetEmployeeById :one
SELECT
  id, name, surname, email, title, description, active, created_at, last_login
FROM
  employees
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetEmployeeById(ctx context.Context, id int32) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployeeById, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.Title,
		&i.Description,
		&i.Active,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getLatestSession = `-- name: GetLatestSession :one
SELECT
  id, user_id, session_token, created_at, expires_at
FROM
  sessions
WHERE
  user_id = $1 -- Replace 123 with the specific user ID
ORDER BY
  created_at DESC
LIMIT
  1
`

func (q *Queries) GetLatestSession(ctx context.Context, userID int32) (Session, error) {
	row := q.db.QueryRow(ctx, getLatestSession, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT
  id
FROM
  roles
WHERE
  name = $1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getRoleRequestByID = `-- name: GetRoleRequestByID :one
SELECT
  id, user_id, requested_role_id, status, comment, approved_by, created_at, approved_at
FROM
  role_requests
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetRoleRequestByID(ctx context.Context, id int32) (RoleRequest, error) {
	row := q.db.QueryRow(ctx, getRoleRequestByID, id)
	var i RoleRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RequestedRoleID,
		&i.Status,
		&i.Comment,
		&i.ApprovedBy,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const getRoleRequestByUser = `-- name: GetRoleRequestByUser :one
SELECT
  id, user_id, requested_role_id, status, comment, approved_by, created_at, approved_at
FROM
  role_requests
WHERE
  user_id = $1
  AND requested_role_id = $2
LIMIT
  1
`

type GetRoleRequestByUserParams struct {
	UserID          int32 `json:"user_id"`
	RequestedRoleID int32 `json:"requested_role_id"`
}

func (q *Queries) GetRoleRequestByUser(ctx context.Context, arg GetRoleRequestByUserParams) (RoleRequest, error) {
	row := q.db.QueryRow(ctx, getRoleRequestByUser, arg.UserID, arg.RequestedRoleID)
	var i RoleRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RequestedRoleID,
		&i.Status,
		&i.Comment,
		&i.ApprovedBy,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const getRoleRequestsWithJoinByID = `-- name: GetRoleRequestsWithJoinByID :one
SELECT
  rr.id AS id,
  rr.user_id AS requesting_user_id,
  rr.requested_role_id AS requested_role_id,
  rr.status AS status,
  rr.comment AS comment,
  rr.approved_by AS approving_user_id,
  rr.created_at AS created_at,
  rr.approved_at AS approved_at,
  -- Requesting user info
  ru.name AS requesting_user_name,
  ru.surname AS requesting_user_surname,
  ru.email AS requesting_user_email,
  ru.created_at AS requesting_user_created_at,
  ru.last_login AS requesting_user_last_login,
  -- Requested role info
  r.name AS requested_role_name,
  r.description AS requested_role_description,
  -- Approving user info
  au.name AS approving_user_name,
  au.surname AS approving_user_surname,
  au.email AS approving_user_email,
  au.created_at AS approving_user_created_at,
  au.last_login AS approving_user_last_login
FROM
  role_requests rr
  LEFT JOIN users ru ON rr.user_id = ru.id
  LEFT JOIN roles r ON rr.requested_role_id = r.id
  LEFT JOIN users au ON rr.approved_by = au.id
WHERE
  rr.id = $1
`

type GetRoleRequestsWithJoinByIDRow struct {
	ID                       int32             `json:"id"`
	RequestingUserID         int32             `json:"requesting_user_id"`
	RequestedRoleID          int32             `json:"requested_role_id"`
	Status                   RoleRequestStatus `json:"status"`
	Comment                  pgtype.Text       `json:"comment"`
	ApprovingUserID          pgtype.Int4       `json:"approving_user_id"`
	CreatedAt                pgtype.Timestamp  `json:"created_at"`
	ApprovedAt               pgtype.Timestamp  `json:"approved_at"`
	RequestingUserName       pgtype.Text       `json:"requesting_user_name"`
	RequestingUserSurname    pgtype.Text       `json:"requesting_user_surname"`
	RequestingUserEmail      pgtype.Text       `json:"requesting_user_email"`
	RequestingUserCreatedAt  pgtype.Timestamp  `json:"requesting_user_created_at"`
	RequestingUserLastLogin  pgtype.Timestamp  `json:"requesting_user_last_login"`
	RequestedRoleName        pgtype.Text       `json:"requested_role_name"`
	RequestedRoleDescription pgtype.Text       `json:"requested_role_description"`
	ApprovingUserName        pgtype.Text       `json:"approving_user_name"`
	ApprovingUserSurname     pgtype.Text       `json:"approving_user_surname"`
	ApprovingUserEmail       pgtype.Text       `json:"approving_user_email"`
	ApprovingUserCreatedAt   pgtype.Timestamp  `json:"approving_user_created_at"`
	ApprovingUserLastLogin   pgtype.Timestamp  `json:"approving_user_last_login"`
}

func (q *Queries) GetRoleRequestsWithJoinByID(ctx context.Context, id int32) (GetRoleRequestsWithJoinByIDRow, error) {
	row := q.db.QueryRow(ctx, getRoleRequestsWithJoinByID, id)
	var i GetRoleRequestsWithJoinByIDRow
	err := row.Scan(
		&i.ID,
		&i.RequestingUserID,
		&i.RequestedRoleID,
		&i.Status,
		&i.Comment,
		&i.ApprovingUserID,
		&i.CreatedAt,
		&i.ApprovedAt,
		&i.RequestingUserName,
		&i.RequestingUserSurname,
		&i.RequestingUserEmail,
		&i.RequestingUserCreatedAt,
		&i.RequestingUserLastLogin,
		&i.RequestedRoleName,
		&i.RequestedRoleDescription,
		&i.ApprovingUserName,
		&i.ApprovingUserSurname,
		&i.ApprovingUserEmail,
		&i.ApprovingUserCreatedAt,
		&i.ApprovingUserLastLogin,
	)
	return i, err
}

const getRolesForUser = `-- name: GetRolesForUser :many
SELECT
  r.name
FROM
  roles r
  JOIN user_roles ur ON ur.role_id = r.id
WHERE
  ur.user_id = $1
`

func (q *Queries) GetRolesForUser(ctx context.Context, userID int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getRolesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT
  id, user_id, session_token, created_at, expires_at
FROM
  sessions
WHERE
  session_token = $1
`

func (q *Queries) GetSessionByToken(ctx context.Context, sessionToken string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, sessionToken)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
  id, name, surname, email, hashed_password, created_at, last_login
FROM
  users
WHERE
  email = $1
LIMIT
  1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.HashedPassword,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT
  id, name, surname, email, hashed_password, created_at, last_login
FROM
  users
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.HashedPassword,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserByIdWithRoles = `-- name: GetUserByIdWithRoles :one
SELECT
  u.id, u.name, u.surname, u.email, u.hashed_password, u.created_at, u.last_login,
  COALESCE(array_agg(r.name), '{}')::text[] as role_names
FROM
  users u
  LEFT JOIN user_roles ur ON ur.user_id = u.id
  LEFT JOIN roles r ON r.id = ur.role_id
WHERE
  u.id = $1
GROUP BY
  u.id
`

type GetUserByIdWithRolesRow struct {
	ID             int32            `json:"id"`
	Name           string           `json:"name"`
	Surname        string           `json:"surname"`
	Email          string           `json:"email"`
	HashedPassword string           `json:"hashed_password"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	LastLogin      pgtype.Timestamp `json:"last_login"`
	RoleNames      []string         `json:"role_names"`
}

func (q *Queries) GetUserByIdWithRoles(ctx context.Context, id int32) (GetUserByIdWithRolesRow, error) {
	row := q.db.QueryRow(ctx, getUserByIdWithRoles, id)
	var i GetUserByIdWithRolesRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Surname,
		&i.Email,
		&i.HashedPassword,
		&i.CreatedAt,
		&i.LastLogin,
		&i.RoleNames,
	)
	return i, err
}

const removeRoleToUser = `-- name: RemoveRoleToUser :exec
DELETE FROM user_roles
WHERE
  user_id = $1
  AND role_id = $2
`

type RemoveRoleToUserParams struct {
	UserID int32 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

func (q *Queries) RemoveRoleToUser(ctx context.Context, arg RemoveRoleToUserParams) error {
	_, err := q.db.Exec(ctx, removeRoleToUser, arg.UserID, arg.RoleID)
	return err
}

const reviewRequest = `-- name: ReviewRequest :one
UPDATE role_requests
SET
  status = $2,
  approved_by = $3,
  approved_at = CURRENT_TIMESTAMP
WHERE
  id = $1
RETURNING
  id, user_id, requested_role_id, status, comment, approved_by, created_at, approved_at
`

type ReviewRequestParams struct {
	ID         int32             `json:"id"`
	Status     RoleRequestStatus `json:"status"`
	ApprovedBy pgtype.Int4       `json:"approved_by"`
}

func (q *Queries) ReviewRequest(ctx context.Context, arg ReviewRequestParams) (RoleRequest, error) {
	row := q.db.QueryRow(ctx, reviewRequest, arg.ID, arg.Status, arg.ApprovedBy)
	var i RoleRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RequestedRoleID,
		&i.Status,
		&i.Comment,
		&i.ApprovedBy,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const updateRoleRequest = `-- name: UpdateRoleRequest :one
UPDATE role_requests
SET
  status = $2,
  approved_at = $3,
  comment = $4
WHERE
  id = $1
RETURNING
  id
`

type UpdateRoleRequestParams struct {
	ID         int32             `json:"id"`
	Status     RoleRequestStatus `json:"status"`
	ApprovedAt pgtype.Timestamp  `json:"approved_at"`
	Comment    pgtype.Text       `json:"comment"`
}

func (q *Queries) UpdateRoleRequest(ctx context.Context, arg UpdateRoleRequestParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateRoleRequest,
		arg.ID,
		arg.Status,
		arg.ApprovedAt,
		arg.Comment,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE sessions
SET
  expires_at = $2
WHERE
  session_token = $1
`

type UpdateSessionParams struct {
	SessionToken string           `json:"session_token"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession, arg.SessionToken, arg.ExpiresAt)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
  id = $1,
  name = $2,
  surname = $3,
  email = $4,
  hashed_password = $5,
  created_at = DEFAULT,
  last_login = DEFAULT
WHERE
  id = $1
RETURNING
  id
`

type UpdateUserParams struct {
	ID             int32  `json:"id"`
	Name           string `json:"name"`
	Surname        string `json:"surname"`
	Email          string `json:"email"`
	HashedPassword string `json:"hashed_password"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Surname,
		arg.Email,
		arg.HashedPassword,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
